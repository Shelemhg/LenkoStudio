<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Portfolio Effects Demo - Lenko Studio</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Inter', system-ui, sans-serif;
            background: #0a0a0a;
            color: #ffffff;
            overflow-x: hidden;
        }

        .demo-section {
            min-height: 100vh;
            padding: 80px 20px 40px;
            border-bottom: 2px solid rgba(255,255,255,0.1);
            position: relative;
        }

        .demo-title {
            text-align: center;
            font-size: 2rem;
            margin-bottom: 10px;
            letter-spacing: 0.05em;
        }

        .demo-description {
            text-align: center;
            color: #888;
            margin-bottom: 40px;
            font-size: 0.9rem;
        }

        /* Navigation */
        .demo-nav {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: rgba(10,10,10,0.95);
            backdrop-filter: blur(12px);
            padding: 20px;
            z-index: 1000;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            display: flex;
            gap: 15px;
            overflow-x: auto;
            flex-wrap: wrap;
            justify-content: center;
        }

        .demo-nav a {
            color: #fff;
            text-decoration: none;
            padding: 8px 16px;
            border-radius: 6px;
            background: rgba(255,255,255,0.08);
            font-size: 0.85rem;
            white-space: nowrap;
            transition: all 0.2s;
        }

        .demo-nav a:hover {
            background: rgba(255,255,255,0.15);
        }

        /* 1. Helix Gallery */
        .helix-container {
            perspective: 2000px;
            height: 600px;
            position: relative;
            overflow: hidden;
        }

        .helix-track {
            position: absolute;
            top: 50%;
            left: 50%;
            transform-style: preserve-3d;
            transition: transform 0.6s cubic-bezier(0.16, 1, 0.3, 1);
        }

        .helix-item {
            position: absolute;
            width: 300px;
            height: 200px;
            left: -150px;
            top: -100px;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(0,0,0,0.6);
            transition: all 0.6s cubic-bezier(0.16, 1, 0.3, 1);
        }

        .helix-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* 2. 3D Coverflow */
        .coverflow-container {
            perspective: 1500px;
            height: 500px;
            position: relative;
            overflow: hidden;
        }

        .coverflow-track {
            position: absolute;
            top: 50%;
            left: 50%;
            transform-style: preserve-3d;
            transition: transform 0.6s cubic-bezier(0.16, 1, 0.3, 1);
        }

        .coverflow-item {
            position: absolute;
            width: 350px;
            height: 250px;
            left: -175px;
            top: -125px;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(0,0,0,0.6);
            transition: all 0.6s cubic-bezier(0.16, 1, 0.3, 1);
        }

        .coverflow-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* 3. Tunnel Vortex Gallery */
        .tunnel-container {
            perspective: 1500px;
            height: 600px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        .tunnel {
            width: 100%;
            height: 100%;
            position: relative;
            transform-style: preserve-3d;
            transition: transform 1s ease-out;
        }

        .tunnel-ring {
            position: absolute;
            left: 50%;
            top: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            transform-style: preserve-3d;
        }

        .tunnel-item {
            position: absolute;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 10px 40px rgba(0,0,0,0.7);
        }

        .tunnel-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* 4. Parallax with Depth */
        .parallax-depth-container {
            position: relative;
            height: 500px;
            overflow: hidden;
            perspective: 1000px;
        }

        .parallax-depth-scene {
            position: relative;
            width: 100%;
            height: 100%;
            transform-style: preserve-3d;
        }

        .parallax-layer {
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            gap: 20px;
            padding: 20px;
            transition: transform 0.1s ease-out;
        }

        .parallax-layer-item {
            flex-shrink: 0;
            width: 300px;
            height: 400px;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
        }

        .parallax-layer-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* 7. Isometric Cascade */
        .isometric-container {
            perspective: 1500px;
            height: 700px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: visible;
        }

        .isometric-grid {
            display: grid;
            grid-template-columns: repeat(4, 200px);
            gap: 20px;
            transform-style: preserve-3d;
            transform: rotateX(45deg) rotateZ(45deg);
        }

        .isometric-item {
            width: 200px;
            height: 150px;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(0,0,0,0.6);
            transition: all 0.4s cubic-bezier(0.16, 1, 0.3, 1);
            cursor: pointer;
        }

        .isometric-item:hover {
            transform: translateZ(100px) scale(1.2);
            z-index: 10;
        }

        .isometric-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* 8. Sphere Gallery */
        .sphere-container {
            perspective: 1500px;
            height: 600px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .sphere {
            width: 300px;
            height: 300px;
            position: relative;
            transform-style: preserve-3d;
            transition: transform 1s ease-out;
        }

        .sphere-item {
            position: absolute;
            width: 200px;
            height: 150px;
            left: 50%;
            top: 50%;
            margin-left: -100px;
            margin-top: -75px;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 10px 40px rgba(0,0,0,0.7);
            backface-visibility: hidden;
        }

        .sphere-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* 5. Physics Carousel */
        .physics-carousel {
            position: relative;
            height: 500px;
            perspective: 1500px;
            overflow: hidden;
            max-width: 900px;
            margin: 0 auto;
        }

        .physics-track {
            position: absolute;
            top: 50%;
            left: 50%;
            transform-style: preserve-3d;
            transition: transform 0.6s cubic-bezier(0.16, 1, 0.3, 1);
        }

        .physics-item {
            position: absolute;
            width: 400px;
            height: 300px;
            border-radius: 16px;
            overflow: hidden;
            left: -200px;
            top: -150px;
            transition: all 0.6s cubic-bezier(0.16, 1, 0.3, 1);
            box-shadow: 0 20px 60px rgba(0,0,0,0.6);
        }

        .physics-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .carousel-controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 40px;
        }

        .carousel-controls button {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .carousel-controls button:hover {
            background: rgba(255,255,255,0.2);
        }

        /* 6. Stacked Layers */
        .stacked-container {
            position: relative;
            height: 600px;
            max-width: 500px;
            margin: 0 auto;
            perspective: 1000px;
        }

        .stacked-item {
            position: absolute;
            width: 100%;
            height: 500px;
            border-radius: 16px;
            overflow: hidden;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            transition: all 0.5s cubic-bezier(0.16, 1, 0.3, 1);
            cursor: grab;
        }

        .stacked-item:active {
            cursor: grabbing;
        }

        .stacked-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            pointer-events: none;
        }

        /* 7. Grid to Detail - removed */

        @media (max-width: 768px) {
            .demo-title {
                font-size: 1.5rem;
            }

            .physics-item {
                width: 300px;
                height: 225px;
                left: -150px;
                top: -112px;
            }

            .coverflow-item {
                width: 280px;
                height: 200px;
            }
        }
    </style>
</head>
<body>
    <nav class="demo-nav">
        <a href="#demo1">Helix Gallery</a>
        <a href="#demo2">3D Coverflow</a>
        <a href="#demo3">Tunnel Vortex</a>
        <a href="#demo4">Parallax Depth</a>
        <a href="#demo5">Physics Carousel</a>
        <a href="#demo6">Stacked Layers</a>
        <a href="#demo7">Isometric Cascade</a>
    </nav>

    <!-- Demo 1: Helix Gallery -->
    <section id="demo1" class="demo-section">
        <h2 class="demo-title">1. Helix Gallery</h2>
        <p class="demo-description">Images arranged in a 3D spiral helix</p>
        <div class="helix-container">
            <div class="helix-track" id="helixTrack">
                <!-- Helix items will be generated by JS -->
            </div>
        </div>
        <div class="carousel-controls">
            <button onclick="helixPrev()">‚Äπ Previous</button>
            <button onclick="helixNext()">Next ‚Ä∫</button>
        </div>
    </section>

    <!-- Demo 2: 3D Coverflow -->
    <section id="demo2" class="demo-section">
        <h2 class="demo-title">2. 3D Coverflow Effect</h2>
        <p class="demo-description">Classic Apple-style coverflow with depth and reflection</p>
        <div class="coverflow-container">
            <div class="coverflow-track" id="coverflowTrack">
                <!-- Items will be generated by JS -->
            </div>
        </div>
        <div class="carousel-controls">
            <button onclick="coverflowPrev()">‚Äπ Previous</button>
            <button onclick="coverflowNext()">Next ‚Ä∫</button>
        </div>
    </section>

    <!-- Demo 3: Tunnel Vortex -->
    <section id="demo3" class="demo-section">
        <h2 class="demo-title">3. Tunnel Vortex Gallery</h2>
        <p class="demo-description">Images recede into a 3D tunnel vortex</p>
        <div class="tunnel-container">
            <div class="tunnel" id="tunnel">
                <!-- Tunnel rings will be generated by JS -->
            </div>
        </div>
        <div class="carousel-controls">
            <button onclick="tunnelRotate()">üîÑ Rotate Tunnel</button>
        </div>
    </section>

    <!-- Demo 4: Parallax Depth -->
    <section id="demo4" class="demo-section">
        <h2 class="demo-title">4. Parallax Depth Layers</h2>
        <p class="demo-description">Move your mouse to see depth-based parallax effect</p>
        <div class="parallax-depth-container" id="parallaxDepthContainer">
            <div class="parallax-depth-scene" id="parallaxScene">
                <!-- Layers will be generated by JS -->
            </div>
        </div>
    </section>

    <!-- Demo 5: Physics Carousel -->
    <section id="demo5" class="demo-section">
        <h2 class="demo-title">5. Interactive Carousel with Physics</h2>
        <p class="demo-description">3D rotation with scale and blur transitions</p>
        <div class="physics-carousel">
            <div class="physics-track" id="physicsTrack">
                <!-- Carousel items will be generated by JS -->
            </div>
        </div>
        <div class="carousel-controls">
            <button onclick="physicsCarouselPrev()">‚Äπ Previous</button>
            <button onclick="physicsCarouselNext()">Next ‚Ä∫</button>
        </div>
    </section>

    <!-- Demo 6: Stacked Layers -->
    <section id="demo6" class="demo-section">
        <h2 class="demo-title">6. Stacked Layers with Pull-to-Reveal</h2>
        <p class="demo-description">Drag down to reveal next image</p>
        <div class="stacked-container" id="stackedContainer">
            <!-- Stacked items will be generated by JS -->
        </div>
    </section>

    <!-- Demo 7: Isometric Cascade -->
    <section id="demo7" class="demo-section">
        <h2 class="demo-title">7. Isometric Cascade</h2>
        <p class="demo-description">Isometric grid with cascading hover effects</p>
        <div class="isometric-container">
            <div class="isometric-grid" id="isometricGrid">
                <!-- Isometric items will be generated by JS -->
            </div>
        </div>
    </section>

    <!-- Demo 8: Sphere Gallery -->
    <section id="demo8" class="demo-section">
        <h2 class="demo-title">8. Sphere Gallery</h2>
        <p class="demo-description">Drag to rotate sphere of images</p>
        <div class="sphere-container">
            <div class="sphere" id="sphere">
                <!-- Sphere items will be generated by JS -->
            </div>
        </div>
        <div class="carousel-controls">
            <button onclick="rotateSphere('left')">‚Üê Rotate</button>
            <button onclick="rotateSphere('right')">Rotate ‚Üí</button>
        </div>
    </section>

    <script>
        // Sample images using placeholder service
        const images = [
            'https://picsum.photos/800/600?random=1',
            'https://picsum.photos/800/600?random=2',
            'https://picsum.photos/800/600?random=3',
            'https://picsum.photos/800/600?random=4',
            'https://picsum.photos/800/600?random=5',
            'https://picsum.photos/800/600?random=6',
            'https://picsum.photos/800/600?random=7',
            'https://picsum.photos/800/600?random=8',
            'https://picsum.photos/800/600?random=9',
            'https://picsum.photos/800/600?random=10',
            'https://picsum.photos/800/600?random=11',
            'https://picsum.photos/800/600?random=12',
        ];

        // Demo 1: Helix Gallery
        let helixIndex = 0;
        const helixTrack = document.getElementById('helixTrack');
        const helixCount = 10;
        
        for (let i = 0; i < helixCount; i++) {
            const item = document.createElement('div');
            item.className = 'helix-item';
            item.innerHTML = `<img src="${images[i % images.length]}" alt="Image ${i+1}">`;
            helixTrack.appendChild(item);
        }

        function updateHelix() {
            const items = helixTrack.children;
            const radius = 300;
            const height = 150;
            
            for (let i = 0; i < items.length; i++) {
                const offset = i - helixIndex;
                const angle = offset * 36; // 36 degrees per item
                const y = offset * height;
                
                const x = Math.sin(angle * Math.PI / 180) * radius;
                const z = Math.cos(angle * Math.PI / 180) * radius - radius;
                
                items[i].style.transform = `
                    translate3d(${x}px, ${y}px, ${z}px)
                    rotateY(${-angle}deg)
                `;
                items[i].style.opacity = Math.abs(offset) > 3 ? 0 : 1;
            }
        }

        function helixPrev() {
            helixIndex = Math.max(0, helixIndex - 1);
            updateHelix();
        }

        function helixNext() {
            helixIndex = Math.min(helixCount - 1, helixIndex + 1);
            updateHelix();
        }

        updateHelix();

        // Demo 2: 3D Coverflow
        let coverflowIndex = 0;
        const coverflowTrack = document.getElementById('coverflowTrack');
        
        images.slice(0, 7).forEach((img, i) => {
            const item = document.createElement('div');
            item.className = 'coverflow-item';
            item.innerHTML = `<img src="${img}" alt="Image ${i+1}">`;
            coverflowTrack.appendChild(item);
        });

        function updateCoverflow() {
            const items = coverflowTrack.children;
            for (let i = 0; i < items.length; i++) {
                const offset = i - coverflowIndex;
                const absOffset = Math.abs(offset);
                items[i].style.transform = `
                    translateX(${offset * 320}px)
                    rotateY(${offset * -50}deg)
                    translateZ(${-absOffset * 100}px)
                    scale(${offset === 0 ? 1 : 0.85})
                `;
                items[i].style.opacity = absOffset > 2 ? 0 : 1;
                items[i].style.zIndex = 100 - absOffset;
            }
        }

        function coverflowPrev() {
            coverflowIndex = Math.max(0, coverflowIndex - 1);
            updateCoverflow();
        }

        function coverflowNext() {
            coverflowIndex = Math.min(6, coverflowIndex + 1);
            updateCoverflow();
        }

        updateCoverflow();

        // Demo 3: Tunnel Vortex
        const tunnel = document.getElementById('tunnel');
        const ringCount = 5;
        const itemsPerRing = 6;
        
        for (let ring = 0; ring < ringCount; ring++) {
            const ringDiv = document.createElement('div');
            ringDiv.className = 'tunnel-ring';
            
            for (let i = 0; i < itemsPerRing; i++) {
                const item = document.createElement('div');
                item.className = 'tunnel-item';
                const imgIndex = (ring * itemsPerRing + i) % images.length;
                item.innerHTML = `<img src="${images[imgIndex]}" alt="Image">`;
                
                const angle = (i / itemsPerRing) * 360;
                const radius = 150 + ring * 50;
                const z = -ring * 300;
                const scale = 1 - ring * 0.15;
                
                const x = Math.cos(angle * Math.PI / 180) * radius;
                const y = Math.sin(angle * Math.PI / 180) * radius;
                
                item.style.width = `${200 * scale}px`;
                item.style.height = `${150 * scale}px`;
                item.style.transform = `
                    translate(-50%, -50%)
                    translate3d(${x}px, ${y}px, ${z}px)
                    rotateZ(${-angle}deg)
                `;
                
                ringDiv.appendChild(item);
            }
            
            tunnel.appendChild(ringDiv);
        }

        let tunnelRotation = 0;
        function tunnelRotate() {
            tunnelRotation += 60;
            tunnel.style.transform = `rotateZ(${tunnelRotation}deg)`;
        }

        // Auto-rotate tunnel
        setInterval(() => {
            tunnelRotation += 0.2;
            tunnel.style.transform = `rotateZ(${tunnelRotation}deg)`;
        }, 50);

        // Demo 4: Parallax Depth with mouse movement
        const parallaxScene = document.getElementById('parallaxScene');
        const parallaxContainer = document.getElementById('parallaxDepthContainer');
        
        // Create 3 layers at different depths
        for (let layer = 0; layer < 3; layer++) {
            const layerDiv = document.createElement('div');
            layerDiv.className = 'parallax-layer';
            layerDiv.style.transform = `translateZ(${-layer * 150}px)`;
            
            images.slice(layer * 4, (layer + 1) * 4).forEach((img, i) => {
                const item = document.createElement('div');
                item.className = 'parallax-layer-item';
                item.innerHTML = `<img src="${img}" alt="Image ${i+1}">`;
                layerDiv.appendChild(item);
            });
            
            parallaxScene.appendChild(layerDiv);
        }

        parallaxContainer.addEventListener('mousemove', (e) => {
            const rect = parallaxContainer.getBoundingClientRect();
            const x = (e.clientX - rect.left) / rect.width - 0.5;
            const y = (e.clientY - rect.top) / rect.height - 0.5;
            
            const layers = parallaxScene.querySelectorAll('.parallax-layer');
            layers.forEach((layer, i) => {
                const depth = (i + 1) * 30;
                layer.style.transform = `
                    translateX(${x * depth}px)
                    translateY(${y * depth}px)
                    translateZ(${-i * 150}px)
                `;
            });
        });

        parallaxContainer.addEventListener('mouseleave', () => {
            const layers = parallaxScene.querySelectorAll('.parallax-layer');
            layers.forEach((layer, i) => {
                layer.style.transform = `translateZ(${-i * 150}px)`;
            });
        });

        // Demo 6: Stacked Layers
        let physicsIndex = 0;
        const physicsTrack = document.getElementById('physicsTrack');
        
        images.slice(0, 6).forEach((img, i) => {
            const item = document.createElement('div');
            item.className = 'physics-item';
            item.innerHTML = `<img src="${img}" alt="Image ${i+1}">`;
            physicsTrack.appendChild(item);
        });

        function updatePhysicsCarousel() {
            const items = physicsTrack.children;
            for (let i = 0; i < items.length; i++) {
                const offset = i - physicsIndex;
                const absOffset = Math.abs(offset);
                items[i].style.transform = `
                    rotateY(${offset * 45}deg) 
                    translateZ(${offset * -200}px)
                    scale(${1 - absOffset * 0.2})
                `;
                items[i].style.filter = `blur(${absOffset * 2}px)`;
                items[i].style.opacity = absOffset > 2 ? 0 : 1;
                items[i].style.zIndex = 100 - absOffset;
            }
        }

        function physicsCarouselPrev() {
            physicsIndex = Math.max(0, physicsIndex - 1);
            updatePhysicsCarousel();
        }

        function physicsCarouselNext() {
            physicsIndex = Math.min(5, physicsIndex + 1);
            updatePhysicsCarousel();
        }

        updatePhysicsCarousel();

        // Demo 7: Isometric Cascade
        const isometricGrid = document.getElementById('isometricGrid');
        images.forEach((img, i) => {
            const item = document.createElement('div');
            item.className = 'isometric-item';
            item.innerHTML = `<img src="${img}" alt="Image ${i+1}">`;
            
            // Add cascading animation delay
            item.style.animationDelay = `${i * 0.1}s`;
            item.style.transform = `translateZ(${(i % 4) * 20}px)`;
            
            isometricGrid.appendChild(item);
        });

        // Demo 8: Sphere Gallery
        const sphere = document.getElementById('sphere');
        const sphereCount = 12;
        
        for (let i = 0; i < sphereCount; i++) {
            const item = document.createElement('div');
            item.className = 'sphere-item';
            item.innerHTML = `<img src="${images[i % images.length]}" alt="Image ${i+1}">`;
            
            const phi = Math.acos(-1 + (2 * i) / sphereCount);
            const theta = Math.sqrt(sphereCount * Math.PI) * phi;
            
            const x = 250 * Math.cos(theta) * Math.sin(phi);
            const y = 250 * Math.sin(theta) * Math.sin(phi);
            const z = 250 * Math.cos(phi);
            
            item.style.transform = `
                translate3d(${x}px, ${y}px, ${z}px)
                rotateY(${theta * 180 / Math.PI}deg)
            `;
            
            sphere.appendChild(item);
        }

        let sphereRotation = 0;
        function rotateSphere(direction) {
            sphereRotation += direction === 'left' ? -45 : 45;
            sphere.style.transform = `rotateY(${sphereRotation}deg)`;
        }

        // Auto-rotate sphere
        setInterval(() => {
            sphereRotation += 0.3;
            sphere.style.transform = `rotateY(${sphereRotation}deg)`;
        }, 50);

        // Demo 6: Stacked Layers
        const stackedContainer = document.getElementById('stackedContainer');
        let stackIndex = 0;
        
        images.slice(0, 6).forEach((img, i) => {
            const item = document.createElement('div');
            item.className = 'stacked-item';
            item.innerHTML = `<img src="${img}" alt="Image ${i+1}">`;
            item.style.top = `${i * 10}px`;
            item.style.transform = `scale(${1 - i * 0.03}) translateY(${i * 5}px)`;
            item.style.zIndex = images.length - i;
            
            let startY = 0;
            item.addEventListener('mousedown', (e) => {
                startY = e.clientY;
            });
            
            item.addEventListener('mouseup', (e) => {
                if (e.clientY - startY > 50) {
                    item.style.transform = 'translateY(100vh) rotateZ(10deg)';
                    item.style.opacity = '0';
                    setTimeout(() => {
                        item.remove();
                    }, 500);
                }
            });
            
            stackedContainer.appendChild(item);
        });

        // Touch support for mobile
        let touchStartX = 0;
        let touchStartY = 0;

        document.addEventListener('touchstart', (e) => {
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        });

        document.addEventListener('touchend', (e) => {
            const touchEndX = e.changedTouches[0].clientX;
            const deltaX = touchEndX - touchStartX;
            
            if (Math.abs(deltaX) > 50) {
                // Swipe detected
                const activeSection = document.elementFromPoint(touchStartX, touchStartY);
                if (activeSection?.closest('#demo5')) {
                    deltaX > 0 ? physicsCarouselPrev() : physicsCarouselNext();
                } else if (activeSection?.closest('#demo2')) {
                    deltaX > 0 ? coverflowPrev() : coverflowNext();
                } else if (activeSection?.closest('#demo1')) {
                    deltaX > 0 ? helixPrev() : helixNext();
                }
            }
        });

        // Smooth scroll
        document.querySelectorAll('.demo-nav a').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                target.scrollIntoView({ behavior: 'smooth', block: 'start' });
            });
        });
    </script>
</body>
</html>
